/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"


//==============================================================================
JMidiTriggerAudioProcessor::JMidiTriggerAudioProcessor()
	: pluginState(XmlElement("pluginState"))
{
	//pluginState = XmlElement("pluginState");
	//pluginState.addChildElement(new XmlElement("xmlFilePath"));
}

JMidiTriggerAudioProcessor::~JMidiTriggerAudioProcessor()
{

}

//==============================================================================
const String JMidiTriggerAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

bool JMidiTriggerAudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool JMidiTriggerAudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool JMidiTriggerAudioProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double JMidiTriggerAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int JMidiTriggerAudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int JMidiTriggerAudioProcessor::getCurrentProgram()
{
    return 0;
}

void JMidiTriggerAudioProcessor::setCurrentProgram (int index)
{
}

const String JMidiTriggerAudioProcessor::getProgramName (int index)
{
    return String();
}

void JMidiTriggerAudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void JMidiTriggerAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need..
}

void JMidiTriggerAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

void JMidiTriggerAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    // In case we have more outputs than inputs, this code clears any output
    // channels that didn't contain input data, (because these aren't
    // guaranteed to be empty - they may contain garbage).
    // I've added this to avoid people getting screaming feedback
    // when they first compile the plugin, but obviously you don't need to
    // this code if your algorithm already fills all the output channels.
    for (int i = getNumInputChannels(); i < getNumOutputChannels(); ++i)
        buffer.clear (i, 0, buffer.getNumSamples());

	MidiBuffer midiOutput;
	int time;
	MidiMessage m;
	String searchString;

	for (MidiBuffer::Iterator i(midiMessages); i.getNextEvent(m, time);)
	{
		addMidiMessageToList(m);
		processMidiInputMessage(m, midiOutput);
	}

	midiMessages.swapWith(midiOutput);
}

//==============================================================================
bool JMidiTriggerAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* JMidiTriggerAudioProcessor::createEditor()
{
    return new JMidiTriggerAudioProcessorEditor (*this);
}

//==============================================================================
void JMidiTriggerAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
	copyXmlToBinary(pluginState, destData);
}

void JMidiTriggerAudioProcessor::setStateInformation(const void* data, int sizeInBytes)
{
	// You should use this method to restore your parameters from this memory block,
	// whose contents will have been created by the getStateInformation() call.
	XmlElement* tmp = getXmlFromBinary(data, sizeInBytes);
	if (tmp) {
		pluginState = *tmp;
		String tmpValue;

		tmpValue = getStateValue("xmlFilePath","");
		if (tmpValue != "") {
			loadXmlFile(tmpValue);
		}
	}
}

void JMidiTriggerAudioProcessor::setStateValue(const String key, const String value)
{
	XmlElement* valNode = pluginState.getChildByName(key);

	if (!valNode) {
		valNode = new XmlElement(key);
		pluginState.addChildElement(valNode);
	}

	valNode->setAttribute("value",value);
}

String JMidiTriggerAudioProcessor::getStateValue(const String key, const String defaultValue)
{
	XmlElement* valNode = pluginState.getChildByName(key);

	if (!valNode) {
		return defaultValue;
	}

	return valNode->getStringAttribute("value",defaultValue);
}

//==============================================================================

bool JMidiTriggerAudioProcessor::loadXmlFile(const File& fi)
{
	log("Loading XML File");
	xmlReadyState = false;
	if (!fi.exists())
	{
		log("Error - file does not exist: " + fi.getFullPathName());
		xmlFilePath = "";
		abortLoadXmlFile();
		return false;
	}
	else 
	{
		xmlFilePath = fi.getRelativePathFrom(File::getCurrentWorkingDirectory());
		setStateValue("xmlFilePath", xmlFilePath.getValue().toString());

		pugi::xml_parse_result xmlReadSuccess = xmlDoc.load_file(xmlFilePath.toString().toRawUTF8());

		if (xmlReadSuccess==false) {
			log("Error while reading XML file: " + String(xmlReadSuccess.description()));
			abortLoadXmlFile();
			return false;
		} else {
			log("Successfully parsed file: " + xmlFilePath.toString());
			if (!loadXmlData()) { abortLoadXmlFile(); return false; };
			xmlReadyState = true;
			generateXmlDocumentation();
			return true;
		}
	}
}

void JMidiTriggerAudioProcessor::abortLoadXmlFile()
{
	xmlReadyState = false;
}


bool JMidiTriggerAudioProcessor::loadXmlFile(const String& filePath)
{
	return this->loadXmlFile(File(filePath));
}

bool JMidiTriggerAudioProcessor::reloadFile()
{
	return this->loadXmlFile(File(xmlFilePath.toString()));
}

bool JMidiTriggerAudioProcessor::loadXmlData()
{
	xmlRootNode = xmlDoc.document_element();
	if (!xmlRootNode) { DBG("Error: No XML root node found. "); return false; }
	DBG("Debug: Selected root node " + String(xmlRootNode.name()));

	xmlEventsNode = xmlRootNode.child("events");
	if (!xmlEventsNode) { DBG("Error: No XML <events> node found. "); return false; }
	DBG("Debug: Selected events group node " + String(xmlEventsNode.name()));

	xmlListenersNode = xmlRootNode.child("listeners");
	if (!xmlListenersNode) { DBG("Error: No XML <listeners> node found. "); return false; }
	DBG("Debug: Selected listeners group node " + String(xmlListenersNode.name()));

	return true;
}

void JMidiTriggerAudioProcessor::generateXmlDocumentation()
{
	if (!xmlReadyState) return;
	log("Debug: Generate documentation");

	String doc = "";
	//pugi::xml_node listenerNode = xmlListenersNode->child("listener");
	pugi::xml_node eventNode;
	Array<pugi::string_t> eventIds;
	pugi::string_t eventName;

	//DBG("Debug: Selected events group node " );

	for (pugi::xml_node listenerNode = xmlListenersNode.child("listener"); listenerNode; listenerNode = listenerNode.next_sibling("listener")) {
		DBG("Debug: Found a listener node");
		doc +=
			"Listener at Channel " + String(listenerNode.attribute("channel").as_string()) +
			" " + String(listenerNode.attribute("type").as_string()) +
			" [ " + String(listenerNode.attribute("key").as_string()) + " " + String(listenerNode.attribute("value").as_string()) + " ] " +
			" \n";

		eventIds = getEventIdsForListener(&listenerNode);
		if (eventIds.size() == 0) {
			doc += "\tListener triggers nothing \n";
		} else {
			//doc += "\tListener has " + String(eventIds.size()) + " triggers assigned. \n";
			for (int i=0; i < eventIds.size(); i++) {
				eventNode = xmlEventsNode.find_child_by_attribute("event", "id", eventIds[i].c_str() );
				if (eventNode) {
					eventName = eventNode.attribute("name").as_string("");
					if (eventName == "") eventName = eventIds[i].c_str();
					doc += "\tEvent #" + String(i+1) + " - " + eventName + "\n";
				}
				else {
					doc += "\tEvent Node '" + String(eventIds[i].c_str()) + "' not found. \n";
				}
			}
		}
	}

	midiDataInfo = doc;
	DBG("Successfully parsed file.");
}

static String getMidiMessageDescription(const MidiMessage& m)
{
	if (m.isNoteOn())           return "Note on " + MidiMessage::getMidiNoteName(m.getNoteNumber(), true, true, 3);
	if (m.isNoteOff())          return "Note off " + MidiMessage::getMidiNoteName(m.getNoteNumber(), true, true, 3);
	if (m.isProgramChange())    return "Program change " + String(m.getProgramChangeNumber());
	if (m.isPitchWheel())       return "Pitch wheel " + String(m.getPitchWheelValue());
	if (m.isAftertouch())       return "After touch " + MidiMessage::getMidiNoteName(m.getNoteNumber(), true, true, 3) + ": " + String(m.getAfterTouchValue());
	if (m.isChannelPressure())  return "Channel pressure " + String(m.getChannelPressureValue());
	if (m.isAllNotesOff())      return "All notes off";
	if (m.isAllSoundOff())      return "All sound off";
	if (m.isMetaEvent())        return "Meta event";

	if (m.isController())
	{
		String name(MidiMessage::getControllerName(m.getControllerNumber()));

		if (name.isEmpty())
			name = "[" + String(m.getControllerNumber()) + "]";

		return "Controller " + name + ": " + String(m.getControllerValue());
	}
	return String::toHexString(m.getRawData(), m.getRawDataSize());
}

void JMidiTriggerAudioProcessor::addMidiMessageToList(const MidiMessage& message, const String& source)
{
	const double time = message.getTimeStamp();

	const int hours = ((int)(time / 3600.0)) % 24;
	const int minutes = ((int)(time / 60.0)) % 60;
	const int seconds = ((int)time) % 60;
	const int millis = ((int)(time * 1000.0)) % 1000;

	const String timecode(String::formatted("%02d:%02d:%02d.%03d",hours,minutes,seconds,millis));
	const String description(getMidiMessageDescription(message));
	const String midiMessageString(timecode + "  -  " + description + " (" + source + ")");

	log(midiMessageString);
}


bool JMidiTriggerAudioProcessor::processMidiInputMessage(const MidiMessage& message, MidiBuffer& midiOutput)
{
	//<listener channel = "2" type = "cc" key = "11" >
	//m = MidiMessage::noteOn(m.getChannel(), m.getNoteNumber(), newVel);

	pugi::xpath_variable_set params;
	bool foundAnyData = false;

	params.add("channel", pugi::xpath_value_type::xpath_type_number);
	params.add("type", pugi::xpath_value_type::xpath_type_string);
	params.add("key", pugi::xpath_value_type::xpath_type_number);

	params.set("channel", double(message.getChannel()));

	if (message.isNoteOn())
	{
		params.set("type", "noteon");
		params.set("key", double(message.getNoteNumber()));
	}
	else if (message.isNoteOff())
	{
		params.set("type", "noteoff");
		params.set("key", double(message.getNoteNumber()));
	}
	else if (message.isController())
	{
		params.set("type", "cc");
		params.set("key", double(message.getControllerNumber()));
	}
	else if (message.isProgramChange())
	{
		params.set("type", "pc");
		params.set("key", double(message.getProgramChangeNumber()));
	}

	pugi::xpath_node targetNode = xmlListenersNode.select_node("listener[@channel='string($channel)'][@type='string($type)'][@key='string($key)']",&params);
	if (targetNode) {
		pugi::xml_node eventNode;
		pugi::xml_node midiNode;
		pugi::string_t outType;
		int outChannel;
		int outKey;
		int sortIndex = 0;
		Array<pugi::string_t> eventIds = getEventIdsForListener(&targetNode.node());
		MidiMessage outMidiMsg;

		//doc += "\tListener has " + String(eventIds.size()) + " triggers assigned. \n";
		for (int i = 0; i < eventIds.size(); i++) {
			eventNode = xmlEventsNode.find_child_by_attribute("event", "id", eventIds[i].c_str());
			if (eventNode) {
				midiNode = eventNode.child("midi");
				for (midiNode; midiNode; midiNode = midiNode.next_sibling("midi")) {
					sortIndex++;
					outChannel = midiNode.attribute("channel").as_int(1);
					outType = midiNode.attribute("type").as_string("");
					outKey = midiNode.attribute("key").as_int(0);
					if (outType == "noteon") {
						outMidiMsg = MidiMessage::noteOn(outChannel, outKey, float(1.0));
					} else if (outType == "noteoff") {
						outMidiMsg = MidiMessage::noteOff(outChannel, outKey, float(1.0));
					} else if (outType == "cc") {
						outMidiMsg = MidiMessage::controllerEvent(outChannel, outKey, float(1.0));
					} else if (outType == "pc") {
						outMidiMsg = MidiMessage::programChange(outChannel, outKey);
					}
					foundAnyData = true;
					midiOutput.addEvent(outMidiMsg, sortIndex);
				}
			}
			else 
			{
				//doc += "\tEvent Node '" + String(eventIds[i].c_str()) + "' not found. \n";
			}
		}
	}
	return foundAnyData;
}


Array<pugi::string_t> JMidiTriggerAudioProcessor::getEventIdsForListener(const pugi::xml_node* listenerNode)
{
	Array<pugi::string_t> EventIds;
	pugi::string_t eventId;
	pugi::xml_node triggerNode;

	// trigger attribute shortcut
	eventId = listenerNode->attribute("trigger").as_string("");
	if (eventId != "") EventIds.add(eventId);

	triggerNode = listenerNode->child("trigger");
	//log("found a trigger node with tag " + String(triggerNode.name()) );
	for (triggerNode; triggerNode; triggerNode = triggerNode.next_sibling("trigger")) {
		eventId = triggerNode.attribute("id").as_string("");
		//log("<trigger> with id "+eventId);
		if (eventId != "") EventIds.add(eventId);
	}

	return EventIds;
}

void JMidiTriggerAudioProcessor::logMidiMessage(const String& txt)
{
	//String tmp = statusLog.getValue().toString();
	//tmp.append("\n" + txt, 2000);
	statusLog += "\n" + txt;
}

void JMidiTriggerAudioProcessor::log(const String& txt)
{
	DBG(txt);
	//String tmp = statusLog.getValue().toString();
	//tmp.append("\n" + txt, 2000);
	statusLog += "\n" + txt;
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new JMidiTriggerAudioProcessor();
}
